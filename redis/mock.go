// Code generated by mockery v1.0.0. DO NOT EDIT.

package redis

import (
	redis "github.com/go-redis/redis/v7"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

// Append provides a mock function with given fields: key, value
func (_m *MockClient) Append(key string, value string) *redis.IntCmd {
	ret := _m.Called(key, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BLPop provides a mock function with given fields: timeout, keys
func (_m *MockClient) BLPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPop provides a mock function with given fields: timeout, keys
func (_m *MockClient) BRPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPopLPush provides a mock function with given fields: source, destination, timeout
func (_m *MockClient) BRPopLPush(source string, destination string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(source, destination, timeout)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BZPopMax provides a mock function with given fields: timeout, keys
func (_m *MockClient) BZPopMax(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BZPopMin provides a mock function with given fields: timeout, keys
func (_m *MockClient) BZPopMin(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BgRewriteAOF provides a mock function with given fields:
func (_m *MockClient) BgRewriteAOF() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BgSave provides a mock function with given fields:
func (_m *MockClient) BgSave() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BitCount provides a mock function with given fields: key, bitCount
func (_m *MockClient) BitCount(key string, bitCount *redis.BitCount) *redis.IntCmd {
	ret := _m.Called(key, bitCount)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, *redis.BitCount) *redis.IntCmd); ok {
		r0 = rf(key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitField provides a mock function with given fields: key, args
func (_m *MockClient) BitField(key string, args ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(key, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// BitOpAnd provides a mock function with given fields: destKey, keys
func (_m *MockClient) BitOpAnd(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpNot provides a mock function with given fields: destKey, key
func (_m *MockClient) BitOpNot(destKey string, key string) *redis.IntCmd {
	ret := _m.Called(destKey, key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpOr provides a mock function with given fields: destKey, keys
func (_m *MockClient) BitOpOr(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpXor provides a mock function with given fields: destKey, keys
func (_m *MockClient) BitOpXor(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitPos provides a mock function with given fields: key, bit, pos
func (_m *MockClient) BitPos(key string, bit int64, pos ...int64) *redis.IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, ...int64) *redis.IntCmd); ok {
		r0 = rf(key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientGetName provides a mock function with given fields:
func (_m *MockClient) ClientGetName() *redis.StringCmd {
	ret := _m.Called()

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientID provides a mock function with given fields:
func (_m *MockClient) ClientID() *redis.IntCmd {
	ret := _m.Called()

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientKill provides a mock function with given fields: ipPort
func (_m *MockClient) ClientKill(ipPort string) *redis.StatusCmd {
	ret := _m.Called(ipPort)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClientKillByFilter provides a mock function with given fields: keys
func (_m *MockClient) ClientKillByFilter(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientList provides a mock function with given fields:
func (_m *MockClient) ClientList() *redis.StringCmd {
	ret := _m.Called()

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientPause provides a mock function with given fields: dur
func (_m *MockClient) ClientPause(dur time.Duration) *redis.BoolCmd {
	ret := _m.Called(dur)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(time.Duration) *redis.BoolCmd); ok {
		r0 = rf(dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *MockClient) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClusterAddSlots provides a mock function with given fields: slots
func (_m *MockClient) ClusterAddSlots(slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...int) *redis.StatusCmd); ok {
		r0 = rf(slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterAddSlotsRange provides a mock function with given fields: min, max
func (_m *MockClient) ClusterAddSlotsRange(min int, max int) *redis.StatusCmd {
	ret := _m.Called(min, max)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StatusCmd); ok {
		r0 = rf(min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterCountFailureReports provides a mock function with given fields: nodeID
func (_m *MockClient) ClusterCountFailureReports(nodeID string) *redis.IntCmd {
	ret := _m.Called(nodeID)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterCountKeysInSlot provides a mock function with given fields: slot
func (_m *MockClient) ClusterCountKeysInSlot(slot int) *redis.IntCmd {
	ret := _m.Called(slot)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(int) *redis.IntCmd); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterDelSlots provides a mock function with given fields: slots
func (_m *MockClient) ClusterDelSlots(slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...int) *redis.StatusCmd); ok {
		r0 = rf(slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterDelSlotsRange provides a mock function with given fields: min, max
func (_m *MockClient) ClusterDelSlotsRange(min int, max int) *redis.StatusCmd {
	ret := _m.Called(min, max)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StatusCmd); ok {
		r0 = rf(min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterFailover provides a mock function with given fields:
func (_m *MockClient) ClusterFailover() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterForget provides a mock function with given fields: nodeID
func (_m *MockClient) ClusterForget(nodeID string) *redis.StatusCmd {
	ret := _m.Called(nodeID)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterGetKeysInSlot provides a mock function with given fields: slot, count
func (_m *MockClient) ClusterGetKeysInSlot(slot int, count int) *redis.StringSliceCmd {
	ret := _m.Called(slot, count)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StringSliceCmd); ok {
		r0 = rf(slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterInfo provides a mock function with given fields:
func (_m *MockClient) ClusterInfo() *redis.StringCmd {
	ret := _m.Called()

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterKeySlot provides a mock function with given fields: key
func (_m *MockClient) ClusterKeySlot(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterMeet provides a mock function with given fields: host, port
func (_m *MockClient) ClusterMeet(host string, port string) *redis.StatusCmd {
	ret := _m.Called(host, port)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterMode provides a mock function with given fields:
func (_m *MockClient) ClusterMode() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ClusterNodes provides a mock function with given fields:
func (_m *MockClient) ClusterNodes() *redis.StringCmd {
	ret := _m.Called()

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterReplicate provides a mock function with given fields: nodeID
func (_m *MockClient) ClusterReplicate(nodeID string) *redis.StatusCmd {
	ret := _m.Called(nodeID)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetHard provides a mock function with given fields:
func (_m *MockClient) ClusterResetHard() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetSoft provides a mock function with given fields:
func (_m *MockClient) ClusterResetSoft() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSaveConfig provides a mock function with given fields:
func (_m *MockClient) ClusterSaveConfig() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSlaves provides a mock function with given fields: nodeID
func (_m *MockClient) ClusterSlaves(nodeID string) *redis.StringSliceCmd {
	ret := _m.Called(nodeID)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterSlots provides a mock function with given fields:
func (_m *MockClient) ClusterSlots() *redis.ClusterSlotsCmd {
	ret := _m.Called()

	var r0 *redis.ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func() *redis.ClusterSlotsCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterSlotsCmd)
		}
	}

	return r0
}

// Command provides a mock function with given fields:
func (_m *MockClient) Command() *redis.CommandsInfoCmd {
	ret := _m.Called()

	var r0 *redis.CommandsInfoCmd
	if rf, ok := ret.Get(0).(func() *redis.CommandsInfoCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CommandsInfoCmd)
		}
	}

	return r0
}

// ConfigGet provides a mock function with given fields: parameter
func (_m *MockClient) ConfigGet(parameter string) *redis.SliceCmd {
	ret := _m.Called(parameter)

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.SliceCmd); ok {
		r0 = rf(parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// ConfigResetStat provides a mock function with given fields:
func (_m *MockClient) ConfigResetStat() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigRewrite provides a mock function with given fields:
func (_m *MockClient) ConfigRewrite() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigSet provides a mock function with given fields: parameter, value
func (_m *MockClient) ConfigSet(parameter string, value string) *redis.StatusCmd {
	ret := _m.Called(parameter, value)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// DBSize provides a mock function with given fields:
func (_m *MockClient) DBSize() *redis.IntCmd {
	ret := _m.Called()

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DebugObject provides a mock function with given fields: key
func (_m *MockClient) DebugObject(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Decr provides a mock function with given fields: key
func (_m *MockClient) Decr(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DecrBy provides a mock function with given fields: key, decrement
func (_m *MockClient) DecrBy(key string, decrement int64) *redis.IntCmd {
	ret := _m.Called(key, decrement)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Del provides a mock function with given fields: keys
func (_m *MockClient) Del(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Dump provides a mock function with given fields: key
func (_m *MockClient) Dump(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Echo provides a mock function with given fields: message
func (_m *MockClient) Echo(message interface{}) *redis.StringCmd {
	ret := _m.Called(message)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(interface{}) *redis.StringCmd); ok {
		r0 = rf(message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: script, keys, args
func (_m *MockClient) Eval(script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalSha provides a mock function with given fields: sha1, keys, args
func (_m *MockClient) EvalSha(sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// Exists provides a mock function with given fields: keys
func (_m *MockClient) Exists(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Expire provides a mock function with given fields: key, expiration
func (_m *MockClient) Expire(key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, expiration)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireAt provides a mock function with given fields: key, tm
func (_m *MockClient) ExpireAt(key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(key, tm)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// FlushAll provides a mock function with given fields:
func (_m *MockClient) FlushAll() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushAllAsync provides a mock function with given fields:
func (_m *MockClient) FlushAllAsync() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDB provides a mock function with given fields:
func (_m *MockClient) FlushDB() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDBAsync provides a mock function with given fields:
func (_m *MockClient) FlushDBAsync() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// GeoAdd provides a mock function with given fields: key, geoLocation
func (_m *MockClient) GeoAdd(key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.GeoLocation) *redis.IntCmd); ok {
		r0 = rf(key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoDist provides a mock function with given fields: key, member1, member2, unit
func (_m *MockClient) GeoDist(key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	ret := _m.Called(key, member1, member2, unit)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string, string, string) *redis.FloatCmd); ok {
		r0 = rf(key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// GeoHash provides a mock function with given fields: key, members
func (_m *MockClient) GeoHash(key string, members ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoPos provides a mock function with given fields: key, members
func (_m *MockClient) GeoPos(key string, members ...string) *redis.GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.GeoPosCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.GeoPosCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoPosCmd)
		}
	}

	return r0
}

// GeoRadius provides a mock function with given fields: key, longitude, latitude, query
func (_m *MockClient) GeoRadius(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, longitude, latitude, query)

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMember provides a mock function with given fields: key, member, query
func (_m *MockClient) GeoRadiusByMember(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, member, query)

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMemberStore provides a mock function with given fields: key, member, query
func (_m *MockClient) GeoRadiusByMemberStore(key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(key, member, query)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoRadiusStore provides a mock function with given fields: key, longitude, latitude, query
func (_m *MockClient) GeoRadiusStore(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(key, longitude, latitude, query)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Get provides a mock function with given fields: key
func (_m *MockClient) Get(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetBit provides a mock function with given fields: key, offset
func (_m *MockClient) GetBit(key string, offset int64) *redis.IntCmd {
	ret := _m.Called(key, offset)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GetRange provides a mock function with given fields: key, start, end
func (_m *MockClient) GetRange(key string, start int64, end int64) *redis.StringCmd {
	ret := _m.Called(key, start, end)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringCmd); ok {
		r0 = rf(key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetSet provides a mock function with given fields: key, value
func (_m *MockClient) GetSet(key string, value interface{}) *redis.StringCmd {
	ret := _m.Called(key, value)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.StringCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HDel provides a mock function with given fields: key, fields
func (_m *MockClient) HDel(key string, fields ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HExists provides a mock function with given fields: key, field
func (_m *MockClient) HExists(key string, field string) *redis.BoolCmd {
	ret := _m.Called(key, field)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.BoolCmd); ok {
		r0 = rf(key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HGet provides a mock function with given fields: key, field
func (_m *MockClient) HGet(key string, field string) *redis.StringCmd {
	ret := _m.Called(key, field)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StringCmd); ok {
		r0 = rf(key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HGetAll provides a mock function with given fields: key
func (_m *MockClient) HGetAll(key string) *redis.StringStringMapCmd {
	ret := _m.Called(key)

	var r0 *redis.StringStringMapCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringStringMapCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStringMapCmd)
		}
	}

	return r0
}

// HIncrBy provides a mock function with given fields: key, field, incr
func (_m *MockClient) HIncrBy(key string, field string, incr int64) *redis.IntCmd {
	ret := _m.Called(key, field, incr)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, int64) *redis.IntCmd); ok {
		r0 = rf(key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HIncrByFloat provides a mock function with given fields: key, field, incr
func (_m *MockClient) HIncrByFloat(key string, field string, incr float64) *redis.FloatCmd {
	ret := _m.Called(key, field, incr)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string, float64) *redis.FloatCmd); ok {
		r0 = rf(key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// HKeys provides a mock function with given fields: key
func (_m *MockClient) HKeys(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HLen provides a mock function with given fields: key
func (_m *MockClient) HLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HMGet provides a mock function with given fields: key, fields
func (_m *MockClient) HMGet(key string, fields ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.SliceCmd); ok {
		r0 = rf(key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// HMSet provides a mock function with given fields: key, fields
func (_m *MockClient) HMSet(key string, fields map[string]interface{}) *redis.StatusCmd {
	ret := _m.Called(key, fields)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) *redis.StatusCmd); ok {
		r0 = rf(key, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// HScan provides a mock function with given fields: key, cursor, match, count
func (_m *MockClient) HScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// HSet provides a mock function with given fields: key, field, value
func (_m *MockClient) HSet(key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(key, field, value)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HSetEx provides a mock function with given fields: key, field, value, t
func (_m *MockClient) HSetEx(key string, field string, value interface{}, t time.Duration) error {
	ret := _m.Called(key, field, value, t)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, interface{}, time.Duration) error); ok {
		r0 = rf(key, field, value, t)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HSetNX provides a mock function with given fields: key, field, value
func (_m *MockClient) HSetNX(key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(key, field, value)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HVals provides a mock function with given fields: key
func (_m *MockClient) HVals(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// Incr provides a mock function with given fields: key
func (_m *MockClient) Incr(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrBy provides a mock function with given fields: key, value
func (_m *MockClient) IncrBy(key string, value int64) *redis.IntCmd {
	ret := _m.Called(key, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrByFloat provides a mock function with given fields: key, value
func (_m *MockClient) IncrByFloat(key string, value float64) *redis.FloatCmd {
	ret := _m.Called(key, value)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, float64) *redis.FloatCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// Info provides a mock function with given fields: section
func (_m *MockClient) Info(section ...string) *redis.StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringCmd); ok {
		r0 = rf(section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Keys provides a mock function with given fields: pattern
func (_m *MockClient) Keys(pattern string) *redis.StringSliceCmd {
	ret := _m.Called(pattern)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LIndex provides a mock function with given fields: key, index
func (_m *MockClient) LIndex(key string, index int64) *redis.StringCmd {
	ret := _m.Called(key, index)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringCmd); ok {
		r0 = rf(key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LInsert provides a mock function with given fields: key, op, pivot, value
func (_m *MockClient) LInsert(key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, op, pivot, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertAfter provides a mock function with given fields: key, pivot, value
func (_m *MockClient) LInsertAfter(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, pivot, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertBefore provides a mock function with given fields: key, pivot, value
func (_m *MockClient) LInsertBefore(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, pivot, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LLen provides a mock function with given fields: key
func (_m *MockClient) LLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPop provides a mock function with given fields: key
func (_m *MockClient) LPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPush provides a mock function with given fields: key, values
func (_m *MockClient) LPush(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPushX provides a mock function with given fields: key, values
func (_m *MockClient) LPushX(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LRange provides a mock function with given fields: key, start, stop
func (_m *MockClient) LRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LRem provides a mock function with given fields: key, count, value
func (_m *MockClient) LRem(key string, count int64, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, count, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LSet provides a mock function with given fields: key, index, value
func (_m *MockClient) LSet(key string, index int64, value interface{}) *redis.StatusCmd {
	ret := _m.Called(key, index, value)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LTrim provides a mock function with given fields: key, start, stop
func (_m *MockClient) LTrim(key string, start int64, stop int64) *redis.StatusCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LastSave provides a mock function with given fields:
func (_m *MockClient) LastSave() *redis.IntCmd {
	ret := _m.Called()

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MGet provides a mock function with given fields: keys
func (_m *MockClient) MGet(keys ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.SliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MSet provides a mock function with given fields: pairs
func (_m *MockClient) MSet(pairs ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, pairs...)
	ret := _m.Called(_ca...)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...interface{}) *redis.StatusCmd); ok {
		r0 = rf(pairs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MSetNX provides a mock function with given fields: pairs
func (_m *MockClient) MSetNX(pairs ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, pairs...)
	ret := _m.Called(_ca...)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(...interface{}) *redis.BoolCmd); ok {
		r0 = rf(pairs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MemoryUsage provides a mock function with given fields: key, samples
func (_m *MockClient) MemoryUsage(key string, samples ...int) *redis.IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...int) *redis.IntCmd); ok {
		r0 = rf(key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Migrate provides a mock function with given fields: host, port, key, db, timeout
func (_m *MockClient) Migrate(host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	ret := _m.Called(host, port, key, db, timeout)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Move provides a mock function with given fields: key, db
func (_m *MockClient) Move(key string, db int) *redis.BoolCmd {
	ret := _m.Called(key, db)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, int) *redis.BoolCmd); ok {
		r0 = rf(key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ObjectEncoding provides a mock function with given fields: key
func (_m *MockClient) ObjectEncoding(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ObjectIdleTime provides a mock function with given fields: key
func (_m *MockClient) ObjectIdleTime(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// ObjectRefCount provides a mock function with given fields: key
func (_m *MockClient) ObjectRefCount(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PExpire provides a mock function with given fields: key, expiration
func (_m *MockClient) PExpire(key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, expiration)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PExpireAt provides a mock function with given fields: key, tm
func (_m *MockClient) PExpireAt(key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(key, tm)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PFAdd provides a mock function with given fields: key, els
func (_m *MockClient) PFAdd(key string, els ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFCount provides a mock function with given fields: keys
func (_m *MockClient) PFCount(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFMerge provides a mock function with given fields: dest, keys
func (_m *MockClient) PFMerge(dest string, keys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.StatusCmd); ok {
		r0 = rf(dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// PTTL provides a mock function with given fields: key
func (_m *MockClient) PTTL(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Persist provides a mock function with given fields: key
func (_m *MockClient) Persist(key string) *redis.BoolCmd {
	ret := _m.Called(key)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string) *redis.BoolCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Ping provides a mock function with given fields:
func (_m *MockClient) Ping() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Pipeline provides a mock function with given fields:
func (_m *MockClient) Pipeline() redis.Pipeliner {
	ret := _m.Called()

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// Pipelined provides a mock function with given fields: fn
func (_m *MockClient) Pipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(fn)

	var r0 []redis.Cmder
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(func(redis.Pipeliner) error) error); ok {
		r1 = rf(fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PubSubChannels provides a mock function with given fields: pattern
func (_m *MockClient) PubSubChannels(pattern string) *redis.StringSliceCmd {
	ret := _m.Called(pattern)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// PubSubNumPat provides a mock function with given fields:
func (_m *MockClient) PubSubNumPat() *redis.IntCmd {
	ret := _m.Called()

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PubSubNumSub provides a mock function with given fields: channels
func (_m *MockClient) PubSubNumSub(channels ...string) *redis.StringIntMapCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringIntMapCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringIntMapCmd); ok {
		r0 = rf(channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringIntMapCmd)
		}
	}

	return r0
}

// Publish provides a mock function with given fields: channel, message
func (_m *MockClient) Publish(channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(channel, message)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.IntCmd); ok {
		r0 = rf(channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Quit provides a mock function with given fields:
func (_m *MockClient) Quit() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RPop provides a mock function with given fields: key
func (_m *MockClient) RPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPopLPush provides a mock function with given fields: source, destination
func (_m *MockClient) RPopLPush(source string, destination string) *redis.StringCmd {
	ret := _m.Called(source, destination)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StringCmd); ok {
		r0 = rf(source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPush provides a mock function with given fields: key, values
func (_m *MockClient) RPush(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RPushX provides a mock function with given fields: key, values
func (_m *MockClient) RPushX(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RandomKey provides a mock function with given fields:
func (_m *MockClient) RandomKey() *redis.StringCmd {
	ret := _m.Called()

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ReadOnly provides a mock function with given fields:
func (_m *MockClient) ReadOnly() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ReadStruct provides a mock function with given fields: key, v
func (_m *MockClient) ReadStruct(key string, v interface{}) error {
	ret := _m.Called(key, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(key, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReadWrite provides a mock function with given fields:
func (_m *MockClient) ReadWrite() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Rename provides a mock function with given fields: key, newkey
func (_m *MockClient) Rename(key string, newkey string) *redis.StatusCmd {
	ret := _m.Called(key, newkey)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RenameNX provides a mock function with given fields: key, newkey
func (_m *MockClient) RenameNX(key string, newkey string) *redis.BoolCmd {
	ret := _m.Called(key, newkey)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.BoolCmd); ok {
		r0 = rf(key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Restore provides a mock function with given fields: key, ttl, value
func (_m *MockClient) Restore(key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(key, ttl, value)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RestoreReplace provides a mock function with given fields: key, ttl, value
func (_m *MockClient) RestoreReplace(key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(key, ttl, value)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SAdd provides a mock function with given fields: key, members
func (_m *MockClient) SAdd(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SCard provides a mock function with given fields: key
func (_m *MockClient) SCard(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SDiff provides a mock function with given fields: keys
func (_m *MockClient) SDiff(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SDiffStore provides a mock function with given fields: destination, keys
func (_m *MockClient) SDiffStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SInter provides a mock function with given fields: keys
func (_m *MockClient) SInter(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SInterStore provides a mock function with given fields: destination, keys
func (_m *MockClient) SInterStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SIsMember provides a mock function with given fields: key, member
func (_m *MockClient) SIsMember(key string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(key, member)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SMembers provides a mock function with given fields: key
func (_m *MockClient) SMembers(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SMembersMap provides a mock function with given fields: key
func (_m *MockClient) SMembersMap(key string) *redis.StringStructMapCmd {
	ret := _m.Called(key)

	var r0 *redis.StringStructMapCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringStructMapCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStructMapCmd)
		}
	}

	return r0
}

// SMove provides a mock function with given fields: source, destination, member
func (_m *MockClient) SMove(source string, destination string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(source, destination, member)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SPop provides a mock function with given fields: key
func (_m *MockClient) SPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SPopN provides a mock function with given fields: key, count
func (_m *MockClient) SPopN(key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(key, count)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRandMember provides a mock function with given fields: key
func (_m *MockClient) SRandMember(key string) *redis.StringCmd {
	ret := _m.Called(key)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SRandMemberN provides a mock function with given fields: key, count
func (_m *MockClient) SRandMemberN(key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(key, count)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRem provides a mock function with given fields: key, members
func (_m *MockClient) SRem(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SScan provides a mock function with given fields: key, cursor, match, count
func (_m *MockClient) SScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// SUnion provides a mock function with given fields: keys
func (_m *MockClient) SUnion(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SUnionStore provides a mock function with given fields: destination, keys
func (_m *MockClient) SUnionStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Save provides a mock function with given fields:
func (_m *MockClient) Save() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Scan provides a mock function with given fields: cursor, match, count
func (_m *MockClient) Scan(cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(cursor, match, count)

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScriptExists provides a mock function with given fields: hashes
func (_m *MockClient) ScriptExists(hashes ...string) *redis.BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.BoolSliceCmd); ok {
		r0 = rf(hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// ScriptFlush provides a mock function with given fields:
func (_m *MockClient) ScriptFlush() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptKill provides a mock function with given fields:
func (_m *MockClient) ScriptKill() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptLoad provides a mock function with given fields: script
func (_m *MockClient) ScriptLoad(script string) *redis.StringCmd {
	ret := _m.Called(script)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Set provides a mock function with given fields: key, value, expiration
func (_m *MockClient) Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(key, value, expiration)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetBit provides a mock function with given fields: key, offset, value
func (_m *MockClient) SetBit(key string, offset int64, value int) *redis.IntCmd {
	ret := _m.Called(key, offset, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, int) *redis.IntCmd); ok {
		r0 = rf(key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetNX provides a mock function with given fields: key, value, expiration
func (_m *MockClient) SetNX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, value, expiration)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SetRange provides a mock function with given fields: key, offset, value
func (_m *MockClient) SetRange(key string, offset int64, value string) *redis.IntCmd {
	ret := _m.Called(key, offset, value)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, string) *redis.IntCmd); ok {
		r0 = rf(key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetStruct provides a mock function with given fields: key, value, ttl
func (_m *MockClient) SetStruct(key string, value interface{}, ttl time.Duration) error {
	ret := _m.Called(key, value, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) error); ok {
		r0 = rf(key, value, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetXX provides a mock function with given fields: key, value, expiration
func (_m *MockClient) SetXX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, value, expiration)

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Shutdown provides a mock function with given fields:
func (_m *MockClient) Shutdown() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownNoSave provides a mock function with given fields:
func (_m *MockClient) ShutdownNoSave() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownSave provides a mock function with given fields:
func (_m *MockClient) ShutdownSave() *redis.StatusCmd {
	ret := _m.Called()

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SlaveOf provides a mock function with given fields: host, port
func (_m *MockClient) SlaveOf(host string, port string) *redis.StatusCmd {
	ret := _m.Called(host, port)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Sort provides a mock function with given fields: key, sort
func (_m *MockClient) Sort(key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(key, sort)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SortInterfaces provides a mock function with given fields: key, sort
func (_m *MockClient) SortInterfaces(key string, sort *redis.Sort) *redis.SliceCmd {
	ret := _m.Called(key, sort)

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Sort) *redis.SliceCmd); ok {
		r0 = rf(key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// SortStore provides a mock function with given fields: key, store, sort
func (_m *MockClient) SortStore(key string, store string, sort *redis.Sort) *redis.IntCmd {
	ret := _m.Called(key, store, sort)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.Sort) *redis.IntCmd); ok {
		r0 = rf(key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// StrLen provides a mock function with given fields: key
func (_m *MockClient) StrLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TTL provides a mock function with given fields: key
func (_m *MockClient) TTL(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Time provides a mock function with given fields:
func (_m *MockClient) Time() *redis.TimeCmd {
	ret := _m.Called()

	var r0 *redis.TimeCmd
	if rf, ok := ret.Get(0).(func() *redis.TimeCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TimeCmd)
		}
	}

	return r0
}

// Touch provides a mock function with given fields: keys
func (_m *MockClient) Touch(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TxPipeline provides a mock function with given fields:
func (_m *MockClient) TxPipeline() redis.Pipeliner {
	ret := _m.Called()

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// TxPipelined provides a mock function with given fields: fn
func (_m *MockClient) TxPipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(fn)

	var r0 []redis.Cmder
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(func(redis.Pipeliner) error) error); ok {
		r1 = rf(fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields: key
func (_m *MockClient) Type(key string) *redis.StatusCmd {
	ret := _m.Called(key)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Unlink provides a mock function with given fields: keys
func (_m *MockClient) Unlink(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAck provides a mock function with given fields: stream, group, ids
func (_m *MockClient) XAck(stream string, group string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, ...string) *redis.IntCmd); ok {
		r0 = rf(stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAdd provides a mock function with given fields: a
func (_m *MockClient) XAdd(a *redis.XAddArgs) *redis.StringCmd {
	ret := _m.Called(a)

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(*redis.XAddArgs) *redis.StringCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// XClaim provides a mock function with given fields: a
func (_m *MockClient) XClaim(a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	ret := _m.Called(a)

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XClaimArgs) *redis.XMessageSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XClaimJustID provides a mock function with given fields: a
func (_m *MockClient) XClaimJustID(a *redis.XClaimArgs) *redis.StringSliceCmd {
	ret := _m.Called(a)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XClaimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// XDel provides a mock function with given fields: stream, ids
func (_m *MockClient) XDel(stream string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreate provides a mock function with given fields: stream, group, start
func (_m *MockClient) XGroupCreate(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupCreateMkStream provides a mock function with given fields: stream, group, start
func (_m *MockClient) XGroupCreateMkStream(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupDelConsumer provides a mock function with given fields: stream, group, consumer
func (_m *MockClient) XGroupDelConsumer(stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(stream, group, consumer)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupDestroy provides a mock function with given fields: stream, group
func (_m *MockClient) XGroupDestroy(stream string, group string) *redis.IntCmd {
	ret := _m.Called(stream, group)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupSetID provides a mock function with given fields: stream, group, start
func (_m *MockClient) XGroupSetID(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XLen provides a mock function with given fields: stream
func (_m *MockClient) XLen(stream string) *redis.IntCmd {
	ret := _m.Called(stream)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XPending provides a mock function with given fields: stream, group
func (_m *MockClient) XPending(stream string, group string) *redis.XPendingCmd {
	ret := _m.Called(stream, group)

	var r0 *redis.XPendingCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.XPendingCmd); ok {
		r0 = rf(stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingCmd)
		}
	}

	return r0
}

// XPendingExt provides a mock function with given fields: a
func (_m *MockClient) XPendingExt(a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	ret := _m.Called(a)

	var r0 *redis.XPendingExtCmd
	if rf, ok := ret.Get(0).(func(*redis.XPendingExtArgs) *redis.XPendingExtCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingExtCmd)
		}
	}

	return r0
}

// XRange provides a mock function with given fields: stream, start, stop
func (_m *MockClient) XRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop)

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRangeN provides a mock function with given fields: stream, start, stop, count
func (_m *MockClient) XRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop, count)

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRead provides a mock function with given fields: a
func (_m *MockClient) XRead(a *redis.XReadArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(a)

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XReadArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadGroup provides a mock function with given fields: a
func (_m *MockClient) XReadGroup(a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(a)

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XReadGroupArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadStreams provides a mock function with given fields: streams
func (_m *MockClient) XReadStreams(streams ...string) *redis.XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.XStreamSliceCmd); ok {
		r0 = rf(streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XRevRange provides a mock function with given fields: stream, start, stop
func (_m *MockClient) XRevRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop)

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRevRangeN provides a mock function with given fields: stream, start, stop, count
func (_m *MockClient) XRevRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop, count)

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XTrim provides a mock function with given fields: key, maxLen
func (_m *MockClient) XTrim(key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(key, maxLen)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimApprox provides a mock function with given fields: key, maxLen
func (_m *MockClient) XTrimApprox(key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(key, maxLen)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAdd provides a mock function with given fields: key, members
func (_m *MockClient) ZAdd(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddCh provides a mock function with given fields: key, members
func (_m *MockClient) ZAddCh(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNX provides a mock function with given fields: key, members
func (_m *MockClient) ZAddNX(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNXCh provides a mock function with given fields: key, members
func (_m *MockClient) ZAddNXCh(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXX provides a mock function with given fields: key, members
func (_m *MockClient) ZAddXX(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXXCh provides a mock function with given fields: key, members
func (_m *MockClient) ZAddXXCh(key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCard provides a mock function with given fields: key
func (_m *MockClient) ZCard(key string) *redis.IntCmd {
	ret := _m.Called(key)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCount provides a mock function with given fields: key, min, max
func (_m *MockClient) ZCount(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZIncr provides a mock function with given fields: key, member
func (_m *MockClient) ZIncr(key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrBy provides a mock function with given fields: key, increment, member
func (_m *MockClient) ZIncrBy(key string, increment float64, member string) *redis.FloatCmd {
	ret := _m.Called(key, increment, member)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, float64, string) *redis.FloatCmd); ok {
		r0 = rf(key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrNX provides a mock function with given fields: key, member
func (_m *MockClient) ZIncrNX(key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrXX provides a mock function with given fields: key, member
func (_m *MockClient) ZIncrXX(key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZInterStore provides a mock function with given fields: destination, store
func (_m *MockClient) ZInterStore(destination string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(destination, store)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(destination, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZLexCount provides a mock function with given fields: key, min, max
func (_m *MockClient) ZLexCount(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZPopMax provides a mock function with given fields: key, count
func (_m *MockClient) ZPopMax(key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZPopMin provides a mock function with given fields: key, count
func (_m *MockClient) ZPopMin(key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRange provides a mock function with given fields: key, start, stop
func (_m *MockClient) ZRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByLex provides a mock function with given fields: key, opt
func (_m *MockClient) ZRangeByLex(key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScore provides a mock function with given fields: key, opt
func (_m *MockClient) ZRangeByScore(key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScoreWithScores provides a mock function with given fields: key, opt
func (_m *MockClient) ZRangeByScoreWithScores(key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeWithScores provides a mock function with given fields: key, start, stop
func (_m *MockClient) ZRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRank provides a mock function with given fields: key, member
func (_m *MockClient) ZRank(key string, member string) *redis.IntCmd {
	ret := _m.Called(key, member)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRem provides a mock function with given fields: key, members
func (_m *MockClient) ZRem(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByLex provides a mock function with given fields: key, min, max
func (_m *MockClient) ZRemRangeByLex(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByRank provides a mock function with given fields: key, start, stop
func (_m *MockClient) ZRemRangeByRank(key string, start int64, stop int64) *redis.IntCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByScore provides a mock function with given fields: key, min, max
func (_m *MockClient) ZRemRangeByScore(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRevRange provides a mock function with given fields: key, start, stop
func (_m *MockClient) ZRevRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByLex provides a mock function with given fields: key, opt
func (_m *MockClient) ZRevRangeByLex(key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScore provides a mock function with given fields: key, opt
func (_m *MockClient) ZRevRangeByScore(key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: key, opt
func (_m *MockClient) ZRevRangeByScoreWithScores(key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(key, opt)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRangeWithScores provides a mock function with given fields: key, start, stop
func (_m *MockClient) ZRevRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(key, start, stop)

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRank provides a mock function with given fields: key, member
func (_m *MockClient) ZRevRank(key string, member string) *redis.IntCmd {
	ret := _m.Called(key, member)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZScan provides a mock function with given fields: key, cursor, match, count
func (_m *MockClient) ZScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ZScore provides a mock function with given fields: key, member
func (_m *MockClient) ZScore(key string, member string) *redis.FloatCmd {
	ret := _m.Called(key, member)

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZUnionStore provides a mock function with given fields: dest, store
func (_m *MockClient) ZUnionStore(dest string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(dest, store)

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(dest, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}
